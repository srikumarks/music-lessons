<!DOCTYPE html>

<html>
    <head>
        <meta charset="utf-8"/>
        <style>
            .label { font-size: 18pt; font-weight: bold }
            .sectionLabel { font-size: 20pt; font-weight: bold; }
        </style>
    </head>
    <body>
        <h1 id="title"></h1>
        <div class="info">
            <span id="type"></span> by <span id="composer"></span>
            <br/>
            <b>Raga:</b> <span id="raga"></span>
            | <span id="arohana"></span>
            | <span id="avarohana"></span>
            <br/>
            <b>Tala:</b> <span id="tala"></span>
        </div>
        <div id="lyrics">
        </div>
        <h2>Translation</h2>
        <div id="translation"></div>
        <div class="notation">
            <svg></svg>
        </div>
        <script src="parser.js"></script>
        <script>
            (function () {
                var request = new XMLHttpRequest();
                request.open('GET', 'ganarajena.notation', true);
                request.onload = function () {
                    var doc = org.sriku.NotationParser(request.responseText);
                    displayMeta(doc);
                    displayNotation(doc, 'div.notation svg');
                };
                request.onerror = function () {
                };
                request.send();
            }());

            function find(tree, label) {
                return findAll(tree, label)[0];
            }

            function findAll(tree, label) {
                label = label.toLowerCase();
                return tree.filter(function (entity) {
                    return entity.label.toLowerCase() === label;
                });
            }

            function q(sel) {
                return document.querySelector(sel);
            }

            function displayMeta(doc) {
                var info = find(doc, 'info');
                var infoFields = info.entities[0];
                q('#title').innerText = infoFields.$title;
                q('#type').innerText = infoFields.$type;
                q('#composer').innerText = infoFields.$composer;
                var raga = find(info.entities, 'raga').entities[0];
                var tala = find(info.entities, 'tala').entities[0];
                q('#raga').innerText = raga.$name;
                q('#arohana').innerText = notationString(raga.$arohana);
                q('#avarohana').innerText = notationString(raga.$avarohana);
                q('#tala').innerText = tala.$name;
                displayBody(find(doc, 'lyrics'), q('#lyrics'));
                displayBody(find(doc, 'translation'), q('#translation'));

                function displayBody(node, element) {
                    node.entities.forEach(function (entity) {
                        if (entity.label === 'paragraph') {
                            entity.entities.forEach(function (line) {
                                element.insertAdjacentHTML('beforeend', line + '<br/>');
                            });
                            element.insertAdjacentHTML('beforeend', '<br/>');
                        } else {
                            element.insertAdjacentHTML('beforeend', '<br/><span class="label">' + entity.label + '</span><br/>');
                            displayBody(entity, element);
                        }
                    });
                }
            }

            function displayNotation(doc, elementSpec) {
                var svg = document.querySelector(elementSpec);
                console.assert(svg);

                var info = find(doc, 'info');
                var tala = find(info.entities, 'tala');
                var notation = find(doc, 'notation');
                console.assert(info && tala && notation);
                var pattern = patternForTala(tala);

                var state = {};
                function loadState(node) {
                    var keys = Object.keys(node).filter(function (k) { return k[0] === '$'; });
                    keys.forEach(function (k) {
                        state[k] = node[k];
                    });
                    return state;
                }
                function pushState() {
                    return state = Object.create(state);
                }
                function popState() {
                    return state = state.__proto__;
                }

                state.scale = 1.75;
                var iSec, iSecN, iPara, iParaN, x = 0, y = 50, patternIx = 0, width = 0;
                notation.entities.forEach(function (node, iSec) {
                    if (node.label === 'paragraph') {
                        loadState(node);
                    } else {
                        y += 25;
                        svgelem(svg, 'text', {x: 0, y: y, style: 'font-size: 18pt; font-weight: bold;'}, node.label);
                        y += 25;
                        patternIx = 0;
                        pushState();
                        node.entities.forEach(typesetPara);
                        popState();
                    }
                });

                svg.setAttribute('width', width);
                svg.setAttribute('height', y);


                function typesetPara(para) {
                    if (para.entities.length > 0) {
                        y += 25;
                        pushState();
                        loadState(para);
                        para.entities.forEach(typesetLine);
                        popState();
                        y += 25;
                    } else {
                        loadState(para);
                    }
                }

                function typesetLine(line) {
                    if (line.match(/^\s*\>/)) {
                        return typesetTextLine(line);
                    } else {
                        return typesetNotation(line);
                    }
                }

                function typesetTextLine(line) {
                    var content = line.trim().split(/^\>\s*/)[1];
                    svgelem(svg, 'text', {x: 0, y: y, style: 'font-size: 14pt;'}, content);
                    y += 25;
                }

                function typesetNotation(line) {
                    var contents = line.trim().split(/\s+/g).map(show);
                    console.assert(pattern);
                    var pi, pN, i, N, x, j;
                    var subdivs = contents.length / parseInt(state['$aksharas per line'], 10);
                    var text = svgelem(svg, 'text', {x: 0, y: y, style: ('font-size:' + (subdivs > 2 ? 12 : 14) + 'pt;')});
                    var lineSpace = 0;
                    for (i = 0, N = contents.length, pi = patternIx, pN = pattern.length, x = 0; i < N; pi = (pi + 1) % pN) {
                        var inst = pattern[pi];
                        if ('tick' in inst) {
                            if (lineSpace > 0) {
                                x += lineSpace;
                                lineSpace = 0;
                            }
                            // Consume one element.
                            for (j = 0; j < subdivs; ++j) {
                                svgelem(text, 'tspan', {x: x}, contents[i]);
                                ++i;
                                x += inst.tick * state.scale / subdivs;
                            }
                        }

                        // Consume other non-tick instructions up to the next tick.
                        while (!('tick' in pattern[(pi + 1) % pN])) {
                            pi = (pi + 1) % pN;
                            if ('space' in pattern[pi]) {
                                x += pattern[pi].space * state.scale;
                                lineSpace = 0;
                            } else if ('line' in pattern[pi]) {
                                svgelem(svg, 'line', {x1: x, y1: y, x2: x, y2: (y - 25), 'stroke-width': 2, stroke: 'black'});
                                x += 5;
                                lineSpace += pattern[pi].line;
                            }
                        }
                    }

                    patternIx = pi % pN;
                    y += 25;
                    width = Math.max(x, width);
                }
            }

            function patternForTala(tala) {
                var pattern;
                var i, N;
                for (i = 0, N = tala.entities.length; i < N; ++i) {
                    pattern = tala.entities[i].$pattern;
                    if (pattern) {
                        break;
                    }
                }

                console.assert(pattern);

                var instrs = [];
                for (i = 0, N = pattern.length; i < N; ++i) {
                    switch (pattern[i]) {
                        case ',': 
                            instrs.push({tick: 40});
                            break;
                        case ' ':
                            instrs.push({space: 10});
                            break;
                        case '|':
                            instrs.push({line: 10});
                            break;
                        default:
                            console.error('Unknown pattern character ' + pattern[i]); // Ignore.
                    }
                }
                            
                return instrs;
            }

            function notationString(str) {
                return str.split(/\s+/g).map(show).join(' ');
            }

            function show(text) {
                var hisa = "Ṡ";
                var losa = "Ṣ";
                if (text === '_') {
                    return "";
                } else if (text.length === 2 && text[1] === '+') {
                    return text[0] + hisa[1];
                } else if (text.length === 2 && text[1] === '-') {
                    return text[0] + losa[1];
                }
                return text;
            }

            function svgelem(elem, n, attrs, content) {
                var tag = document.createElementNS('http://www.w3.org/2000/svg', n);
                if (attrs) {
                    for (var k in attrs) {
                        if (attrs[k]) {
                            tag.setAttribute(k, attrs[k]);
                        }
                    }
                }
                if (content) {
                    tag.textContent = content;
                }
                elem.appendChild(tag);
                return tag;
            }
        </script>
    </body>
</html>
